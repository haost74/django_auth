{% extends 'lessonsbase.html' %}

{% block contentln %}
<div class="container d-flex align-items-center justify-content-center">
<h1>Урок 9. Что такое ООП?</h1>
</div>
<div class="container d-flex align-items-center justify-content-center">
<p  class="abz">Время прочтения: 6 минуты </p>
</div>

<div class="block1" align="justify" >
  <p class="abz">Циклы, ветвления и функции – все это элементы структурного программирования. Его возможностей вполне хватает для написания небольших, простых программ и сценариев.
Однако крупные проекты часто реализуют, используя парадигму объектно-ориентированного программирования (ООП). Что оно из себя представляет и какие преимущества дает?</p>
  <p class="abz">Истоки ООП берут начало с 60-х годов XX века. Однако окончательное формирование основополагающих принципов и популяризацию идеи следует отнести к 80-м годам.
Большой вклад внес Алан Кей.</p>
  <p class="abz">В языке Python ООП играет ключевую роль. Даже программируя в рамках структурной парадигмы, вы все равно пользуетесь объектами и классами, пусть даже встроенными в язык,
а не созданными лично вами.</p>
  <p class="abz">Итак, что же такое объектно-ориентированное программирование? Судя по названию, ключевую роль здесь играют некие объекты, на которые ориентируется весь процесс программирования.</p>
  <p class="abz">Если мы взглянем на реальный мир под тем углом, под которым привыкли на него смотреть, то для нас он предстанет в виде множества объектов, обладающих определенными свойствами, взаимодействующих
между собой и вследствие этого изменяющимися. Эта привычная для взгляда человека картина мира была перенесена в программирование.</p>
         <p class="abz">Она потребовала более высокого уровня абстракции от того, как вычислительная машина хранит и обрабатывает данные, потребовала от программистов умения конструировать своего рода "виртуальные миры",
распределять между собой задачи. Однако дала возможность более легкой и продуктивной разработки больших программ.</p>
         <p class="abz">Ключевую разницу между программой, написанной с структурном стиле, и объектно-ориентированной можно выразить так. В первом случае, на первый план выходит логика, понимание последовательности выполнения
действий для достижения поставленной цели. Во-втором – важнее представить программу как как систему объектов, взаимодействие которых способно решить ту или иную задачу.</p>
         <p class="abz">Основными понятиями, используемыми в ООП, являются класс, объект, наследование, инкапсуляция и полиморфизм. В языке Python класс равносилен понятию тип данных.</p>
		 <p class="abz">Класс и объект</p>
		 <p class="abz">Что такое класс или тип? Проведем аналогию с реальным миром. Если мы возьмем конкретный стол, то это объект, но не класс. А вот общее представление о столах, их назначении – это класс. Ему принадлежат все
реальные объекты столов, какими бы они ни были. Класс столов дает общую характеристику всем столам в мире, он их обобщает.</p>
		 <p class="abz">То же самое с целыми числами в Python. Тип int – это класс целых чисел. Числа 5, 100134, -10 и т. д. – это конкретные объекты этого класса.</p>
 <p class="abz">В языке программирования Python объекты принято называть также экземплярами. Это связано с тем, что в нем все классы сами являются объектами класса type. Точно также как все модули являются объектами класса module.</p>
         <p class="abz">Поэтому во избежании путаницы объекты, созданные на основе обычных классов, называют экземплярами.</p>
         <p class="abz">Наследование, инкапсуляция, полиморфизм</p>
 <p class="abz">Следующее по важности понятие объектно-ориентированного программирования – наследование. Вернемся к столам. Пусть есть класс столов, описывающий общие свойства всех столов. Однако можно разделить все столы на письменные,
 обеденные и журнальные и для каждой группы создать свой класс, который будет наследником общего класса, но также вносить ряд своих особенностей. Таким образом, общий класс будет родительским, а классы групп – дочерними, производными.</p>
         <p class="abz">Дочерние классы наследуют особенности родительских, однако дополняют или в определенной степени модифицируют их характеристики. Когда мы создаем конкретный экземпляр стола, то должны выбрать, какому классу столов он
будет принадлежать. Если он принадлежит классу журнальных столов, то получит все характеристики общего класса столов и класса журнальных столов. Но не особенности письменных и обеденных.</p>
         <p class="abz">Основное (но не единственное) преимущество, которое дает концепция наследования в программировании, – это вынос одинакового кода из разных классов в один родительский класс. Другими словами, наследование позволяет
сводить на нет повторение кода в разных частях программы.</p>
         <p class="abz">Инкапсуляция в ООП понимается двояко. Во многих языках этот термин обозначает сокрытие данных, то есть невозможность напрямую получить доступ к внутренней структуре объекта, так как это небезопасно. Например, наполнить
желудок едой можно напрямую, положив еду в желудок. Но это опасно. Поэтому прямой доступ к желудку закрыт. Чтобы наполнить его едой, надо совершить ритуал, через элемент интерфейса под названием рот.</p>
         <p class="abz">В Python нет такой инкапсуляции, хотя она является одним из стандартов ООП. В Python можно получить доступ к любому атрибуту объекта и изменить его. Однако в Питоне есть механизм, позволяющий имитировать сокрытие данных,
если это так уж необходимо.</p>
 <p class="abz">Отсутствие сокрытия данных в Python делает программирование на нем проще, но привносит ряд особенностей, связанных с пространствами имен.</p>
         <p class="abz">Второй смысл инкапсуляции – объединение описания свойств объектов и их поведения в единое целое, то есть в класс. Инкапсуляция в этом смысле вытекает из самой идеи объектно-ориентированного программирования и, соответственно,
имеется во всех ОО-языках.</p>
         <p class="abz">Полиморфизм можно перевести как множество форм. В ООП под полиморфизмом понимается следующее. Объекты разных классов, с разной внутренней реализацией, то есть программным кодом, могут иметь "одинаковые" методы. На самом деле
у методов совпадают только имена, а вложенный в них код (то, что они делают) различен. Вот и получается, что у одного имени как бы множество форм.<p>
 <p class="abz">Используя любой из вышеперечисленных подходов, при вызове функции из импортированного модуля, вам всегда придется указывать имя модуля (или псевдоним).
 Для того, чтобы этого избежать делайте импорт через конструкцию from … import…</p>
         <p class="abz">Например, для чисел есть операция сложения, обозначаемая знаком +. Однако мы можем определить класс, объекты которого также будут поддерживать операцию, обозначаемую этим знаком. Но это вовсе не значит, что объекты должны быть
числами, и будет получаться какая-то сумма. Операция + для объектов нашего класса может значить что-то иное. Но интерфейс, в данном случае это знак +, у чисел и нашего класса будет одинаков. Полиморфность же проявляется во внутренней реализации и результате операции.</p>
         <p class="abz">Вы уже сталкивались с полиморфизмом операции +. Для чисел она обозначает сложение, а для строк – конкатенацию. Внутренняя реализация кода для этой операции у чисел отличается от реализации таковой для строк.</p>
         <p class="abz">Полиморфизм полезен не только тем, что дает возможность объектам пользовательских классов участвовать в стандартных операциях. Если у объектов разных классов есть одноименный метод, то коллекция таких разнородных объектов может быть обработана в
 одном цикле.</p>

<p class="abz">Вопрсы</p>
    <form method="post">
<span class="quesion_n">1.Что является основными элементами ООП?</span>
<ul>
<li><input type="radio" name="test[1]" value="0" id="test_1_0_1"  onclick="updateButtonState(this)"/> <label for="test_1_0_1">Циклы, ветвления и функции</label></li>
<li><input type="radio" name="test[1]" value="1" id="test_1_1_1"  onclick="updateButtonState(this)"/> <label for="test_1_1_1">Классы и объекты</label></li>
<li><input type="radio" name="test[1]" value="2" id="test_1_2_1"  onclick="updateButtonState(this)"/> <label for="test_1_2_1">Переменные</label></li>
</ul>
<span class="quesion_n">2.Выберите НЕВЕРНОЕ утверждение</span>
<ul>
<li><input type="radio" name="test[2]" value="0" id="test_1_0_2"  onclick="updateButtonState(this)"/> <label for="test_1_0_2">Бабочка - класс, бабочка Махаон - экземпляр класса</label></li>
<li><input type="radio" name="test[2]" value="1" id="test_1_1_2"  onclick="updateButtonState(this)"/> <label for="test_1_1_2">Дом - класс, комната - экземпляр класса</label></li>
<li><input type="radio" name="test[2]" value="2" id="test_1_2_2"  onclick="updateButtonState(this)"/> <label for="test_1_2_2">Машина - класс, машина Audi - экземпляр класса</label></li>
</ul>
<span class="quesion_n">3.Чем удобно наследование?</span>
<ul>
<li><input type="radio" name="test[3]" value="0" id="test_1_0_3"  onclick="updateButtonState(this)"/> <label for="test_1_0_3">вынос одинакового кода из разных классов в один родительский класс</label></li>
<li><input type="radio" name="test[3]" value="1" id="test_1_1_3"  onclick="updateButtonState(this)"/> <label for="test_1_1_3">сокрытие данных, то есть невозможность напрямую получить доступ к внутренней структуре объекта, так как это небезопасно.</label></li></label></li>
<li><input type="radio" name="test[3]" value="2" id="test_1_2_3"  onclick="updateButtonState(this)"/> <label for="test_1_2_3">дает возможность объектам пользовательских классов участвовать в стандартных операциях. </label></li></label></li>
</ul>
<span class="quesion_n">4.Какой из примеров можно отнести к инкапсуляции?</span>
<ul>
<li><input type="radio" name="test[4]" value="0" id="test_1_0_4"  onclick="updateButtonState(this)"/> <label for="test_1_0_4">Бензонасос поставляет бензин в двигатель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает поступательное движение поршня во вращательное движение колёс. Сейчас все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. </label></li>
<li><input type="radio" name="test[4]" value="1" id="test_1_1_4"  onclick="updateButtonState(this)"/> <label for="test_1_1_4">При устройстве на работу, каждый сотрудник заполняет один и тот же документ с основными полями, но если у человека есть какие-либо льготы ему следует заполнить документ для льготников, который будет содержать поля из основного документы и дополнительные для льгот.</label></li>
<li><input type="radio" name="test[4]" value="2" id="test_1_2_4"  onclick="updateButtonState(this)"/> <label for="test_1_2_4">У слова ручки есть два значения, в зависимости от применения мы понимаем о чем идет речь, хотя название одно.</label></li>
</ul>
<span class="quesion_n">5.Что понимается под полиморфизмом?</span>
<ul>
<li><input type="radio" name="test[5]" value="0" id="test_1_0_5"  onclick="updateButtonState(this)"/> <label for="test_1_0_5">Объекты разных классов, с разной внутренней реализацией, то есть программным кодом, могут иметь "одинаковые" методы. </label></li>
<li><input type="radio" name="test[5]" value="1" id="test_1_1_5"  onclick="updateButtonState(this)"/> <label for="test_1_1_5">Механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.</label></li>
<li><input type="radio" name="test[5]" value="2" id="test_1_2_5"  onclick="updateButtonState(this)"/> <label for="test_1_2_5">Выделение значимой информации и исключение из рассмотрения незначимой.</label></li>
</ul>

{% csrf_token %}
      <button id="btn-input" type="submit" name="run_script"
              class="btn btn-info" style="display: none">
          Проверить результаты</button>
     <script>
        var list = [];
        function updateButtonState(inpt){
         if(inpt){
            console.log(list.length);
            if(!list.includes(inpt.name)){
              list.push(inpt.name)
            }
           }

           let n =  document.getElementsByTagName("ul").length;
             if(list.length >= n){
               document.getElementById('btn-input').style.display = 'block';
               }
        }
    </script>
  </form>
  </div>




{% endblock %}
